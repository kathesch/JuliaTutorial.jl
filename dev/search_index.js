var documenterSearchIndex = {"docs":
[{"location":"#Numerical-methods-in-Julia-tutorial","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"","category":"section"},{"location":"#Introduction","page":"Numerical methods in Julia tutorial","title":"Introduction","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Welcome to JuliaTutorial.jl! The aim of this page is to get you quickly started with the Julia programming language.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"I think Julia is perhaps the most productive gateway to the world of numerical methods for scientific computing, and I hope this can be a self-contained resource to get you started with Julia, its ecosystem, and exploring numerical methods.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: What is Julia and why should you learn it\nJulia is a scientific programming language comparable to python, matlab, fortran, and R. It was originally created in 2012 by Jeff Bezanson, Stefan Karpinski, Viral Shah (and others) in the MIT Computational Science and Aritifical Intelligence Lab (CSAIL) as an open source project. Since then, the language has amassed 8000 officially registered packages and become a dominant language for instruction and research in applied math departments at several top research universities, notably MIT and Stanford[]. The Julia community is still small compared to python, but in its niche of numerical computing, it is already very well established. The primary purpose for creating Julia was solving the \"two language problem\". This is where a scientific programmer implementing complex algorithms in high-level/abstract languages (commonly python) must then convert or interface this code to a low-level/systems language (commonly C++/fortran) in order to get efficient performance. Practically speaking, the two language problem means scientists must use C++/fortran (with all their many headaches) to get high performance software or else hope that someone else wrote something relevant in C++/fortran and made a convenient python interface for it such as numpy or scipy.Julia has arguably solved this problem through JIT (just-in-time) compilation along with host of other design decisions which enable a python-like syntax, but with the capability of C++/fortran speeds. This means we can make, for instance, a linear algebra package in pure Julia and have it run as fast (or sometimes faster) than C++/fortran ones such as openBLAS.This does come at the cost - mostly in added precompilation time when a function is first called. But I believe it is well worth it for most use cases in scientific computing. ","category":"page"},{"location":"#Installation","page":"Numerical methods in Julia tutorial","title":"Installation","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Julia can be installed from its official download page.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"It can also be installed via homebrew (on macs) by pasting the following command into a terminal. This command will install the current stable release (currently 1.8.1).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"brew install --cask julia","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Simply typing julia in a terminal to open a Julia REPL (read-evaluate-print-loop) session. You can use the REPL to evaluate simple Julia expression, manage Julia packages, run shell commands, and access documentation. Additionally, you can run a Julia file in you active directory by typing julia my_julia_program.jl. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's open a julia REPL and type print(\"hello world\").","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"~ % julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.8.1 (2022-09-06)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> print(\"hello world\")\nhello world","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"The REPL is a great interface for using Julia quickly (to make a fast plot, overview your packages, or do a small calculation), but we will need a robust IDE (Integrated Development Environment) to write more complex code. There are many IDE's for various programming languages including Julia, but the easiest and most fully featured one for Julia is VS Code which we will install in the next section. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: On Julia versions\nJulia, like most actively used software, is under a constant state of development. This means you will find various older and newer versions of Julia out in the wild. These versions are distinguished by a version number, for example, 1.8.1 or 0.7.2. This release scheme is very common in open source software (know as the semantic versioning specification). The first number indicates a major release. For Julia this was the 1.0.0 release in 2018. 1.0.0 is considered a major milestone for open source development as it typically represents a commitment to major design decisions in the software and a certain amount of stability to what its interface looks like.The following two numbers are respectively a minor release and patch number. Minor releases are usually every 4-5 months. And patches are released as needed. You can read more about Julia's release process here.Typically, Julia code written for 1.0.0 will work if run by later versions of Julia (this is known as backwards compatability). However code written for a newer Julia version cannot be assumed to run on an earlier Julia version i.e. it is not forward compatible. This is usually because it incorporates language features which are not parseable by earlier Julia versions.Practically speaking, if you keep Julia updated to the current stable release, you won't run into version issues, but if you find yourself needing to use many different versions of Julia, for instance, if you want to test the latest releases or want to use a very old package, you can use the juliaup tool to conveniently manage many different Julia versions. ","category":"page"},{"location":"#Using-Julia-in-VS-Code","page":"Numerical methods in Julia tutorial","title":"Using Julia in VS Code","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"VS Code can be installed from its official download page.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"It can also be installed via homebrew (on macs).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"brew install --cask visual-studio-code","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"You can then open VS Code by typing code into a terminal. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"The Julia extension can be install by clicking the following extension button in the upper left of VS Code.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"(Image: )","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Search for \"julia\", and then click the blue install button. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"    <img src=\"2022-09-26-15-00-34.png\" width=200/>","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Next, let's make a .jl file to edit. Click new file.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"<img src=\"2022-09-26-15-31-34.png\" width=200/>","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"And select Julia File to initialize a blank Julia file.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"<img src=\"2022-09-26-15-37-07.png\" width=400/>","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Finally, let's open up a REPL inside of VS Code (called the integrated terminal) using the default hotkey ctrl + J + O.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Congratulations! We are now set-up for working with Julia. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"<img src=\"2022-09-26-15-43-27.png\" width=400/>","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: About VS Code\nVS Code is designed to be a highly customizable, general purpose IDE which can work with just about any programming languages. It's most powerful features for Julia programming are:An \"extension marketplace\" where you can install extensions to the IDE which give it support for various programming languages, color schemes and syntax highlighting, quality of life tools, and many others. \nGit integration which lets you quickly and seamlessly push commits to a remote git repository.\nRemote development support which lets you develop and run code on other computers with nearly exactly the same workflow as your local machine. This is very convenient for working on cloud computing tools like AWS's EC2 as well as more traditional high performance computing infrastructure.","category":"page"},{"location":"#Writing-simple-Julia-programs","page":"Numerical methods in Julia tutorial","title":"Writing simple Julia programs","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Type 1+1 into the editor window in VS Code and press shift + enter to execute the line your cursor is on (or execute multiple lines if you have them highlighted). By default, it will print an \"inline result\" next to the code as well as in the REPL session below your editor. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"(Image: )","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This lends itself to an interactive workflow much like a jupyter notebook. This is the most basic workflow and suitable for writing scripts and exploring data, but if you are doing package development with unit tests and more complicated environments you will want to look at Revise.jl.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: Resources for learning Julia syntax\nWhile this tutorial is meant to be a self-contained introduction to using the Julia language, I can't realistically guide you through all the in's and out's of its syntax. Here are a list of references in order of increasing time commitment which will be useful to you to pick up the syntax and bridge it with your existing knowledge of python. matlab-python-julia cheatsheet - Quick way to see syntax differences between python and Julia for common operations\nThe Fast Track to Julia - Overview of the Julia language in one page\nOfficial Julia languages documentation - Comprehensive overview of the entire language\nJulia for Talented Amateurs - Extensive youtube channel with tutorials on most parts of the language, data analysis, GPU computing, etc. Also, many great memes. ","category":"page"},{"location":"#The-Julia-package-manager","page":"Numerical methods in Julia tutorial","title":"The Julia package manager","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Julia packages such as DifferentialEquations.jl or Plots.jl are collections of functions which can be imported to provide additional functionality to your Julia program. They are equivalent to libraries in other languages, for instance, python's numpy and Julia's LinearAlgebra.jl provide similar functionality. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"The Julia package manager, Pkg.jl, is itself a package, and it lets us import packages from various locations on the internet and manage them. It is essentially python's pyp and conda/venv all in one. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can access Pkg.jl in two ways. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This is the less common way, but it can be accessed like any Julia package by typing using Pkg in either your editor window (with shift+enter) or the REPL. You can then import other packages (here Plots.jl) by typing Pkg.add(\"Plots.jl\"). This will download Plots.jl from its official github repo to your ~/.julia/packages folder and updates your project.toml file in .julia/environments/1.8 which contains the default v1.8 environment. You can then access Plots.jl functions at any time by running using Plots.jl in Julia. \nThe more common way is using the built in REPL interface. Type ] into your REPL window. The julia> prompt will change into (@v1.8) pkg> indicating it now accepts Pkg.jl functions (use backspace to return to julia>). We can type add Plots to do the same thing we did above. In addition to add you can also remove/rm packages, list all your current packages with status/st, or run unit tests for the package test Plots.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: Accessing documentation and shell commands from the REPL\nPkg.jl is not the only tool with a nice REPL interface. We can access the documentation for a function or function call by typing ? which will change julia> into a help?> prompt. Copy and paste code you want to know more about there to get its docstring, examples, and often a list of similar functions. Try pasting print(\"help me!\") into it.Shell commands can also be called from the Julia REPL by typing ; to get shell>. Typical shell commands like ls or cd work here exactly as they do in an external terminal.","category":"page"},{"location":"#Plotting","page":"Numerical methods in Julia tutorial","title":"Plotting","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Creating plots is perhaps the most fundamental thing you can do in scientific computing and it is also probably the quickest and most fun way to learn Julia.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"To make a plot in Julia, run the following. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"using Plots\nplot(sin)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can also call plot on an array. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"plot([1,2,4,2,5])","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Or put one plot on top of another by calling plot!. In Julia, it is convention to put a \"!\" after a function which modifies data. In this case, plot!([1,2,4,2,5]) writes over our previous plot(sin).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"plot(sin)\nplot!([1,2,4,2,5])","category":"page"},{"location":"#Understanding-the-plot-function-call","page":"Numerical methods in Julia tutorial","title":"Understanding the plot function call","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's take a minute to unpack the function call plot(sin). The function plot is explicitly exported from the \"Plots.jl\" package, so we do not need to write Plots.plot to specify it (though we would if we if we were working with several different plotting packages at once).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This function consists of many \"sub-functions\" known as \"methods\" which are specialized to different arguments for the function. When you call the function plot(sin), Julia sees that you called plot on a single argument sin of type Function (functions are treated as just another data type in Julia such as Int64, FLoat64, etc). It can then use a method of plot which calls the function sin on a few values (here -5 to 5) which serve as the values on the x-axis. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"In contrast, plot([1,2,4,2,5]) uses a slightly different method where it generates (x,y) coordinates based off of the index of the value in the array and the actual value of the array respectively.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"It is worth pointing out here that unlike python and many other programming languages, Julia has 1-based arrays meaning the first index is 1 not 0 which is why you see the array plotted as 1 to 5 on the x-axis. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: Multiple dispatch and polymorphism\nBeing able to infer what method to call based on the types of arguments is known as \"multiple  dispatch\" and it is the core design feature of the Julia language. It let's us have a ton of flexibility in a single function call such as plot. The rough equivalent of multiple dispatch in other languages is function overloading (in C/C++) or objects in object oriented language (such as python and C++). The main purpose of multiple dispatch or object-oriented development is to create \"polymorphism\" in our program.Without using polymorphism we would be forced to write an ugly interface like plot_array and plot_function which would be extremely difficult for anyone to remember, and if we wanted to change anything about how we plot in general, we'd have to rewrite the code for every single one of such functions.","category":"page"},{"location":"#Making-animations-with-a-few-important-language-features","page":"Numerical methods in Julia tutorial","title":"Making animations with a few important language features","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"It is also possible to make simple animations in Plots.jl.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's make a sine wave which translates itself to the right. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"@gif for t in 0:0.5:6\n    plot(x->sin(x-t))\nend","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"There is a lot of syntax to unpack here, but I think it introduces many important language features of Julia.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"@gif is a \"macro\"\nfor t in 0:0.5:6...end is a \"for loop\"\nx->sin(x-t) is an \"anonymous function\" or \"lambda\"","category":"page"},{"location":"#Macros","page":"Numerical methods in Julia tutorial","title":"Macros","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Macros can be thought of as a generalization of the idea of a function.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"A function takes arguments which are various data types for instance sin takes in types of Number such as Int64, Float64, etc and gives you a value you would associate with sin from its mathematical definition.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"But instead of taking normal data types like Int64, a macro takes a piece of Julia code as an argument. This is an example of what is known as \"metaprogramming\". In this case, @gif uses our for loop with a plot call inside as a recipe to make an animation. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"You will likely rarely write these, but you will encounter and use them everywhere in the Julia ecosystem. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"The most useful macro in Base Julia is @time which will time the code after it. Just a function, you can read the documentation for a macro by using ?@time in a REPL. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"@time sin(pi/2)\nnothing # hide","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: Benchmarking\nBenchmarktools.jl has a more advanced version @btime which gives you more information than @time.julia> @btime sin(pi/2)\n1.167 ns (0 allocations: 0 bytes)BenchmarkTools.jl also allows you to profile code with @benchmark.  Here @benchmark runs code repeatedly and collects statistics on its performance. We can chain macros together, so lets add @time to check how long it to took get these statistics (you can see the @time result at the top).julia> @time @benchmark plot(sin)\n10.841423 seconds (247.36 M allocations: 5.504 GiB, 10.66% gc time, 0.31% compilation time)\nBenchmarkTools.Trial: 5812 samples with 1 evaluation.\nRange (min … max):  786.833 μs …   6.679 ms  ┊ GC (min … max): 0.00% … 80.84%\nTime  (median):     805.958 μs               ┊ GC (median):    0.00%\nTime  (mean ± σ):   858.419 μs ± 416.177 μs  ┊ GC (mean ± σ):  3.84% ±  6.87%\n\n██▆▄▃▃▂▂▁▁ ▁▁                                                 ▁\n██████████████▇▇▇▇▆▆▆▅▅▅▄▄▅▃▅▁▃▄▄▃▁▁▃▁▃▁▃▁▄▁▁▃▃▁▁▁▃▁▁▁▁▁▁▁▃▁▃ █\n787 μs        Histogram: log(frequency) by time        1.6 ms <\n\nMemory estimate: 497.41 KiB, allocs estimate: 21325.","category":"page"},{"location":"#For-loops","page":"Numerical methods in Julia tutorial","title":"For loops","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Most programming languages have constructions called \"for loops\" which allow execution of code repeatedly. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"In Julia the typical syntax is for i in Iterators...end. Note \"white space\" is not as important in Julia as it is in python for i in 1:5 end is a valid loop in Julia. This is the fastest and most flexible way of making a for loop and is therefore the most commonly used for writing numerical methods.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"i is the index variable and takes on the value of every element in \"Iterator\". Iterators are any data structure with many elements and an a ordering such as arrays, strings, and ranges. Here 1:5 is of type Range. We could also specify 1:2:5 to count by 2's or range(0,2pi,length=5) to go from 0 to 2pi in 5 steps.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"for i in 1:5\n    print(i)\nend\nnothing # hide","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: Other common patterns for making for loops\nThere are 3 other patterns for making for loops you will see in Julia (and other languages). These are typically used as a convenient syntax for applying some function element-wise to an array and returning the resulting array which is normally a little awkward to do with the usual for loop syntax. A \"list comprehension\". Very often we want to use a for loop to actually return an array for us rather than just loop through something. List comprehensions provide a nice syntax for this operation. julia> [sin(i) for i in 1:3]\n3-element Vector{Float64}:\n0.8414709848078965\n0.9092974268256817\n0.1411200080598672There is an alternative form called a \"generator comprehension\" which is seen more often in numerical code. It is exactly the same as above, but it doesn't allocate memory (it behaves more like a Range). You can alsoprepend a function julia> (i for i in 1:3)\nBase.Generator{UnitRange{Int64}, typeof(identity)}(identity, 1:3)\njulia>sum(i for i in 1:3)\n6\"Vectorized functions\" provide another fast syntax for applying a function to an iterator and returning an array. Simply put a . after the function to make it apply to every element in an array. For [infix(https://en.wikipedia.org/wiki/Infix_notation) operators] such as + you can put it before the operator such as [1:3] .+ [1:3] or .+(1:3,1:3).    sin.(1:3)\n3-element Vector{Float64}:\n0.8414709848078965\n0.9092974268256817\n0.1411200080598672The map function is yet another common way to apply a function to every element in an iterator.  julia> map(sin, 1:3)\n3-element Vector{Float64}:\n0.8414709848078965\n0.9092974268256817\n0.1411200080598672","category":"page"},{"location":"#Anonymous-functions","page":"Numerical methods in Julia tutorial","title":"Anonymous functions","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"In many cases, we will want to define small functions that are essentially only used once in a program. Rather than clutter everything up with their definitions, we can use anonymous functions also sometimes called \"lambdas\".","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"These are written like x->sin(x) or (x,t)->sin(x-t) for multiple arguments.  Compare with python lambda x: sin(x).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"By putting them in parentheses, we can call them like a normal function. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"julia> (x->sin(x))(pi/2) == sin(pi/2)\ntrue","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"note: Piping functions with |>\nAnonymous functions are very useful if you have many functions you want to nest together. For instance, instead of writing something like:f(x,y) = plot(sin(cos(atan(y/x)+2)^2)or equivalentlyn = cos(atan(y/x)+2)^2\nb = sin(n)\np = plot(b)We can get rid of a lot of parentheses by using a pipe operator |> which sends the output of the argument before it to the argument after it. This can often be much more readable. f(x,y) = atan(y/x) |> _->cos(_+2)^2 |> sin |> plot","category":"page"},{"location":"#The-Julia-ecosystem","page":"Numerical methods in Julia tutorial","title":"The Julia ecosystem","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"The Julia ecosystem has ~8000 packages in the official registry. These can be viewed and searched on JuliaHub, and any one can be imported through Pkj.jl add. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"I think one good informal place to start to get a feel for the scope of the current Julia community and its ecosystem is by looking at the playlist of presentations for JuliaCon 2022. We can see a strong focus primarily in applied mathematics, GPU and distributed computing, physics, economics, teaching, and statistics/data science. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Here is also a lineup of some notable packages that physical chemistry people might be interested in. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Scientific Computing","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"SciML: This is a huge, unified ecosystem for doing scientific machine learning. Its documentation splash page is also a good place to discover scientific computing packages both in and outside its framework. \nDifferentialEquations.jl: The most notable member of the SciML ecosystem and probably the most comprehensive framework for numerically solving ordinary differential equations out there. \nFlux.jl: This is the main framework for machine learning in Julia and provide similar functionality to python's PyTorch. Compared to python machine learning frameworks, it is extremely lightweight and explicit. In fact, Flux.jl's documentation describes how you could have built Flux.jl yourself by simply making convenience functions for regressions using automatic differentiation. \nZygote.jl: Julia's main automatic differentiation package and is what powers Flux.jl. It has a similar lightweight/explict design philosophy. The book Numerical Methods for Scientific Computing has a great tutorial on how to build an automatic differentiation tool in Julia similar to Zygote.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Plotting","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Plots.jl: The jack-of-all-trades standard plotting package. Has many backends and a simple syntax to make quick and dirty plots.\nMakie.jl: An extremely flexible GPU powered plotting package. Can make nice statistical plots and also interactive interfaces for \"plots\" which are borderline simple video games. \nGadfly.jl: Specialized for making really clean, composable statistical plots. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Computer Algebra Systems","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"MathLink.jl: Wolfram Mathematica has a completely free and lightly licensed version known as WolframEngine (can easily install it with brew). You can use it independently, but this is a really excellent interface in Julia that can bridge the gap between computational and analytic methods though at some performance cost. \nSymbolics.jl: The pure Julia equivalent of Mathematica. It is not as user friendly or flexible as Mathematica particuarly with symbolic integration, but it is much faster and support auto-differentiation. \nMetaTheory.jl: The backend for Symbolics.jl. You can define generic relationships between data structure in an abstract algebra-y way such as introducing an identity operation or a distributive property. It can then use Julia's metaprogramming interface and a concept known as E-graph saturation to simplify expressions of these structures. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Quantum","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Quantum Optics.jl: This is the biggest quantum package in the Julia ecosystem and similar to python's QuTip.\nOpenQuantumTools.jl: Contains performant solvers, mostly using DifferentialEquations.jl for working with open quantum systems. ","category":"page"},{"location":"#Making-a-linear-solver-with-LU-decomposition","page":"Numerical methods in Julia tutorial","title":"Making a linear solver with LU decomposition","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's write our first numerical algorithm!","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"There are many candidates for a \"hello world\" numerical algorithm, for instance forward/backward euler methods for ODEs, but I think LU decomposition is perhaps the most fundamental and instructive. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"LU decomposition, despite its modern name, has a long history. It can be thought of as simply gaussian elimination (only popularized by Gauss - Newton invented it in the Western world). This technique was first documented by Chinese mathematicians in AD 179 who used a unique form of computational tool known as rod calculus to execute the algorithm. This was one of the earliest formal uses of something like a computer algorithm as well as solving a linear system of equations, an ubiquitous task in scientific computing. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's start from this wikipedia example of what the gaussian elimination looks like as a starting point for our algorithm. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"<img src=\"2022-09-29-06-22-00.png\" width=400/>","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Without doing any kind of pivots in our augmented matrix (exchange of rows), our takeaway from this should be that solving a linear system looks a bit like manipulating it into a upper triangular form (forward elimination) followed by manipulating it into simultaneously lower triangular form (backward elimination) which yields an identity matrix and a solution.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"More explicitly, starting from the first column of that (augmented) matrix A_aug, we apply exactly the row operations (adding and multiplying multiples of one row of a matrix to another) such that we zero out the elements below the diagonal. Do this for every column of the matrix. Then we do the same thing except in reverse starting from the last column of the matrix and above the diagonal to get our identity matrix. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can think of the first step as multiplying some matrix L^-1 to A to form an upper triangular matrix U. L^-1A=U By inverting this matrix and enforcing a uniqueness condition on L such that we have as many free variables LU as in A (L must be lower triangular and have diagonal entries equal to 1), we recover the LU decomposition. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"beginequation\n\nbeginbmatrix\na_11  a_12  a_13 \na_21  a_22  a_23 \na_31  a_32  a_33 \nendbmatrix \n=\nbeginbmatrix\n    1  0  0 \n    l_21  1  0 \n    l_31  l_32  1 \nendbmatrix\nbeginbmatrix\nu_11  u_12  u_13 \n0  u_22  u_23 \n0  0  u_33 \nendbmatrix \nendequation","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"There is one small issue with this scheme in that if a_11 is 0 or just very small, then u_11 must also be 0, and LU no longer has the same rank as A (which is defined to be a nice invertible square matrix). This presents a contradiction which is easily resolved by multiplying a permutation matrix P to A to get an a_11 with a nicer value. Multiplication of a permutation matrix from the left can be thought of as simple exchanging the rows of A, so this method is sometimes called LU with partial pivoting (only rows) or the LUP decomposition. ","category":"page"},{"location":"#Implementing-in-Julia","page":"Numerical methods in Julia tutorial","title":"Implementing in Julia","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Our numerical scheme will have three parts. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Compute L and U given A (LU decomposition)\nSolve Ly = b for y. (forward elimination)\nSolve Ux = y for x.  (backward elimination)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"If we have LU=A, then solving Ax=b is just solving LUx=b. First solve for Ux with Ux = L^-1b, then x with x=U^-1L^-1b.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's implement forward elimination in Julia first, as it is the easiest. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"beginequation\nbeginbmatrix\n1    \nl_21  1  \nvdots   ddots \nl_n1  l_n2  dots 1 \nendbmatrix \nbeginbmatrix\ny_1 \ny_2\nvdots\ny_n \nendbmatrix \n=\nbeginbmatrix\nb_1 \nb_2\nvdots \nb_n \nendbmatrix \n\nendequation","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Expand out the matrix multiplication:","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"l_i1y_1+dots+l_ii-1y_i-1 + y_i=b_i","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Solve for y_i. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"y_i = b_i -sumlimits_j=1^i-1l_ijy_j","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"From here we can see y_i is just b_i minus all the previous values of y_i-1 to y_1 multiplied by l_ii-1 to l_i1. You can think of the range l_ii-1:l_i1 as being just the the values to left of the 1 on the row corresponding to y_i.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can adapt this expression into Julia using a for loop. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"function forward_elimination(L,b)\n    n = size(L,1)\n    y = zeros(n)\n    for i in 1:n\n        y[i] = b[i] - sum(L[i,j] * y[j] for j=1:i-1; init=0)\n    end\n    return y\nend","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Breaking the following function down a little:","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"n = size(L,1) gives us the number of rows along in L.\ny = zeros(n) initializes an array of zeros. \ny[i] = ... assigns values to this array\nsum(L[i,j] * y[j] for j=1:i-1; init=0) uses \"generator comprehension\" syntax (see for loops) to model the summation. init=0 is a keyword argument that tells the sum function to return 0 when its argument is empty which is the case when i = 1 and i-1=0.\nreturn y outputs our filled array y.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's test the accuracy of this expression by comparing with Julia's lu from LinearAlgebra.jl and \\.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"using LinearAlgebra\n\nA = rand(5,5)\nb = [1.2, -2.3, 5.6, 800, 0.01] # test array ideally covers a variety of numbers\nL,U = lu(A, NoPivot()) # with pivoting turned off to make it like our algorithm\n\nL\\b","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"function forward_elimination(L,b)\n    n = size(L,1)\n    y = zeros(n)\n    for i in 1:n\n        y[i] = b[i] - sum(L[i,j] * y[j] for j=1:i-1; init=0)\n    end\n    return y\nend\n\nforward_elimination(L,b)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can see these are in agreement. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"When making a numerical algorithm, we go from a mathematical expression to a piece of code. Ideally, that piece of code is initially made quite close to the mathematical expression to make it easy to tweak and debug.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"However, there are almost always modifications we want to make to that code to make it much faster or have other desireable design features (such as having a similar interface as other functions in our code base or work with multiple different cases.).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's touch up forward elimination to make it faster. The biggest change we can make is to remove the unnecessary y array. b[i] at the current and future iterations is the only information we need. Earlier indices of b are essentially just free real estate that we can assign output to. This will make the function a \"mutating\" one i.e. it modifies an array outside of the function scope (not initialized inside the function). ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Mutation is the source of many computer bugs and headaches in software, but it is well worth it for performance. To make it easier to identify bugs from mutation, the Julia convention is to write a ! after the function. We therefore have forward_elimination!. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"b = [1.2, -2.3, 5.6,4.5,0.01] # hide\nfunction forward_elimination!(L,b)\n    n = size(L,1)\n    for i in 1:n\n        b[i] = b[i] - sum(L[i,j] * b[j] for j=1:i-1; init=0)\n    end\n    return b\nend\n\nforward_elimination!(L,b)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Which gives us the expected correct results.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We need to benchmark our results to see if this was actually worth it. And as you can see below, we are getting an almost 3x improvement over Julia's \\ withforward_elimination. forward_elimination! gives us a 2x improvement on top of that (total 6x)!. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"using BenchmarkTools\n@btime L\\b\nnothing # hide","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"@btime forward_elimination(L,b)\nnothing # hide","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"@btime forward_elimination!(L,b)\nnothing # hide","category":"page"},{"location":"#Backward-elimination","page":"Numerical methods in Julia tutorial","title":"Backward elimination","text":"","category":"section"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"beginequation\nbeginbmatrix\nu_11   u_12  dots u_1n\n  u_22  dots  u_2n\n   ddots  vdots \n     u_nn \nendbmatrix \nbeginbmatrix\nx_1 \nx_2\nvdots\nx_n \nendbmatrix \n=\nbeginbmatrix\ny_1 \ny_2\nvdots \ny_n \nendbmatrix \nendequation","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can use a similar analysis as forward elimination. Here we have.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"u_iix_i+u_ii+1+dots+u_inx_n=y_i","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Solve for x_i","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"x_i = frac1u_iileft(y_i -sumlimits_j=1+i^nu_ijx_jright)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"In the expression above, the only notable difference from the previous case we can see are: ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Because we don't have 1s all along the diagonal, solving for x_i gives us a divisor u_ii\nLimits of the summation are now different because we must sum values along each row to the right instead of from the left. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"A naive modification of the forward elimination case might look like this (making the changes above and substituting a few variables to make our notation consistent).","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"function backward_elimination(U,y)\n    n = size(U,1)\n    x = zeros(n)\n    for i in 1:n\n        x[i] = 1/U[i,i]*(y[i] - sum(U[i,j] * x[j] for j=1+i:n; init=0))\n    end\n    return x\nend","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We will need to test it to make sure we aren't forgetting anything.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"A = rand(5,5)\ny = [1.2, -2.3, 5.6,4.5,0.01]\nL,U = lu(A, NoPivot())\n\nU\\y","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"backward_elimination(U,y)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Comparing these two results from bottom to top, we see that our backwards_elimination starts off well, but then gets very confused. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This is a critical lesson to learn with computational algorithms - mathematical expressions do not always contain all the information we need to translate it to a computer. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"In this case, in our for loop, we were starting from 1 instead of the n. Our algorithm was dutifully using our x array filled with 0s to compute the long sum for x_1 instead of starting from the single known case of x_n and building up to x_1.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"We can fix this problem, by calling reverse on our range for i. We could also use n:-1:1 to do it more like python, but reverse is probably a little easier to read. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"y = [1.2, -2.3, 5.6,4.5,0.01] # hide\nfunction backward_elimination!(U,y)\n    n = size(U,1)\n    x = zeros(n)\n    for i in reverse(1:n)\n        x[i] = (1/U[i,i]) * (y[i] - sum(U[i,j]*x[j] for j=1+i:n; init=0))\n    end\n    return x\nend\nnothing #hide","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"y = [1.2, -2.3, 5.6,4.5,0.01] # hide\nbackward_elimination!(U,y)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"And let's make similar changes as forward_elimination! to yield backward_elimination!. This just means replacing x and y with b and removing our allocation of the x array. This will give a similar 2x speed improvement over backward_elimination and give us a common notation across all our elimination functions with just b instead of x,y,b.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"function backward_elimination!(U,b)\n    n = size(U,1)\n    for i in reverse(1:n)\n        b[i] = (1/U[i,i]) * (b[i] - sum(U[i,j]*b[j] for j=1+i:n; init=0))\n    end\n    return b\nend","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"y = [1.2, -2.3, 5.6,4.5,0.01] # hide\nbackward_elimination!(U,y)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Finally, we can make the LU decomposition. This can be viewed as solving for the zeros the polynomial equation LU-A=0 with arbitrary constants a_ij. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"beginequation\nleft\nbeginarrayccc\n u_11-a_11  u_12-a_12  u_13-a_13 \n l_21 u_11-a_21  -a_22+l_21 u_12+u_22  -a_23+l_21 u_13+u_23 \n l_31 u_11-a_31  -a_32+l_31 u_12+l_32 u_22  -a_33+l_31 u_13+l_32 u_23+u_33 \nendarray\nright=0\nendequation","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"It is a bit funny that one of the simplest ways of solving a general linear system is actually to first a polynomial system. Polynomial/nonlinear systems hiding behind \"simple\" algorithms is a very common theme in applied math and computer science.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This is a little annoying for us implementing a solver, but it isn't without its rewards. One possible explanation for the flexibility and ubiquitousness of linear system solvers at the heart of so many problems, for instance, linear regression, newton's method, physics inverse problems, etc is the solvers for them already come prepackaged with sophisticated math. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Okay, but how do we actually solve that monster? ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"beginequation\nleft(\nbeginarraycccc\n u_11-a_11  u_12-a_12  dots  u_1m-a_1m \n l_21 u_11-a_21  l_21 u_12+u_22-a_22    l_21 u_1m+u_2m-a_2m \n vdots    ddots  vdots \n l_n1 u_11-a_n1  l_n1 u_12+l_n2 u_22-a_n2  dots  l_n1 u_1m+l_n2 u_2m+dots+l_nm-1u_n-1m + u_nm-a_nm \nendarray\nright)\nendequation","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"There are really three parts to this system of equations.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"The first row is super nice. We know all values a_ij and a_1j = u_1j. So we now know all values u_1j. \nThe next easiest area is the first column. It has only one variable we don't know yet which is l_i1. Solving for it we get l_i1 = fraca_i1u_11\nFinally, since we have the first column and the first row, we can see the only unknown in the second column is l_i2. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This suggests it is possible to build out the matrix column-by-column from the left.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Let's write a program for this. Notice that, since the only overlap of the L and U matrices is on the diagonal and we know the diagonal values of L are 1, so we lose nothing by storing all our values in the original matrix.","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"function LU_decomposition!(A)\n    n = Size(A,1)\n    for j in 1:n #loop every column\n        for i in j+1:n #every row below the jth\n            A[i,j] = A[i,j]/A[j,j]\n            for k in j+1:n #adding ij/jk terms to the rest of the row to the right of A[i,j]\n                A[i,k] = A[i,k] - A[i,j]*A[j,k]\n            end\n        end\n    end\nreturn A\nend","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Testing this to see that it generates the correct behaviors","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"A = reshape(collect(1:16),4,4)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"l,u = lu(A)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"LU_decomposition!(A)","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"In base Julia (and matlab and other languages), solving a linear system is so common, that it has its own infix operator called the left division operator \\ which solves the matrix equation Ax=b for x. Let's test it really quickly. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"A = rand(5,5) #Random 5 by 5 array\nb = rand(5)\nx = A\\b\n@time A*x - b #Should be approximately 0","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"Under the hood, \\ is what is known as a polyalgorithm. Based off of what type of matrix you give, i.e. is it square, sparse, has certain symmetries, etc it is able to dispatch a \"pretty good\" algorithm for the job. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"What algorithm is \"pretty good\" is actually very relative to your exact use, so you might need to make explicit choices about your algorithm by using packages such as LinearSolve.jl. Particularly for large systems, in extreme cases, algorithm choice can mean the difference between solving it in hours or seconds. ","category":"page"},{"location":"","page":"Numerical methods in Julia tutorial","title":"Numerical methods in Julia tutorial","text":"This is why that although you will likely never actually use your own linear solver, it can be helpful to know what different algorithms exist and have some insight as to what they are good at. For instance, that LU decomposition is fastest for small, dense matrices, singular value decomposition and qr algorithm are expensive, but can make up for it in precision, and that iterative methods are great for large systems compared to factorization methods (from LinearSolver.jl docs)","category":"page"}]
}
